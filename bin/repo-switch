#!/usr/bin/env python3

import hashlib
import os
import re
import subprocess
import sys
import tempfile
from pathlib import Path
from shlex import quote as sh_quote

_VALID_VAR = re.compile(r"^[A-Za-z_][A-Za-z0-9_]*$")


def write_env_file():
    """Serialize current environment to a sourceable shell script."""
    fd, path = tempfile.mkstemp(prefix="repo-switch-env-", suffix=".sh")
    with os.fdopen(fd, "w") as f:
        for key, value in os.environ.items():
            if _VALID_VAR.match(key):
                f.write(f"export {key}={sh_quote(value)}\n")
    return path


def ensure_symlink(path, target):
    """Atomically create or update a symlink."""
    target = str(target)
    if path.is_symlink() and os.readlink(path) == target:
        return
    tmp = path.with_suffix(".tmp")
    tmp.unlink(missing_ok=True)
    tmp.symlink_to(target)
    tmp.rename(path)


def main():
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <target-path>")
        sys.exit(1)

    target = Path(sys.argv[1]).resolve()
    repo_root_env = os.environ.get("MAIN_REPO_ROOT")
    if not repo_root_env:
        print("Error: MAIN_REPO_ROOT not set")
        sys.exit(1)

    repo_root = Path(repo_root_env).expanduser()
    repo_name = repo_root.name
    state_dir = Path.home() / ".local" / "state" / "repo-symlinks" / repo_name
    expected_link = str(state_dir / "target")
    cache_dir = Path.home() / ".cache" / "repo-symlinks"

    # Ensure MAIN_REPO_ROOT uses the indirection structure:
    #   ~/fbsource -> ~/.local/state/repo-symlinks/fbsource/target -> <real root>
    if not repo_root.is_symlink():
        print(f"Error: MAIN_REPO_ROOT={repo_root} is not a symlink")
        sys.exit(1)

    current_link = os.readlink(repo_root)
    if current_link != expected_link:
        # Resolve the real root before rewiring
        real_root = repo_root.resolve()
        state_dir.mkdir(parents=True, exist_ok=True)
        ensure_symlink(state_dir / "target", real_root)
        ensure_symlink(repo_root, expected_link)
        print(f"Rewired {repo_root} -> {expected_link} -> {real_root}")
    elif not (state_dir / "target").is_symlink():
        # Indirection dir exists but missing target symlink
        real_root = repo_root.resolve()
        state_dir.mkdir(parents=True, exist_ok=True)
        ensure_symlink(state_dir / "target", real_root)

    # Prepare mount source: a directory containing a `target` symlink
    h = hashlib.sha256(str(target).encode()).hexdigest()[:16]
    mount_src = cache_dir / h
    mount_src.mkdir(parents=True, exist_ok=True)
    ensure_symlink(mount_src / "target", target)

    state_dir.mkdir(parents=True, exist_ok=True)

    shell = os.environ.get("SHELL", "/bin/zsh")
    pwd = os.getcwd()
    uid, gid = os.getuid(), os.getgid()

    # Persist full environment across sudo/setpriv boundary
    env_file = write_env_file()

    # Bind mount the cache dir over state_dir, restore env, drop back to user
    inner = (
        f"set -e; "
        f"mount --bind {sh_quote(str(mount_src))} {sh_quote(str(state_dir))}; "
        f"cd {sh_quote(pwd)}; "
        f". {sh_quote(env_file)}; "
        f"rm -f {sh_quote(env_file)}; "
        f"exec setpriv --reuid={uid} --regid={gid} --init-groups {sh_quote(shell)} -i"
    )

    try:
        subprocess.run(
            [
                "sudo",
                "unshare",
                "--mount",
                "--propagation",
                "private",
                "/bin/sh",
                "-c",
                inner,
            ],
            check=False,
        )
    finally:
        Path(env_file).unlink(missing_ok=True)


if __name__ == "__main__":
    main()
